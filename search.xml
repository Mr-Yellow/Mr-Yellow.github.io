<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Explainable Recommendation： A Survey and New Perspectives</title>
      <link href="/2020/07/13/Explainable-Recommendation%EF%BC%9A-A-Survey-and-New-Perspectives/"/>
      <url>/2020/07/13/Explainable-Recommendation%EF%BC%9A-A-Survey-and-New-Perspectives/</url>
      
        <content type="html"><![CDATA[<h1 id="Explainable-Recommendation：-A-Survey-and-New-Perspectives"><a href="#Explainable-Recommendation：-A-Survey-and-New-Perspectives" class="headerlink" title="Explainable Recommendation： A Survey and New Perspectives"></a>Explainable Recommendation： A Survey and New Perspectives</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>可解释的推荐模型（explainable recommendation）不仅仅产生高质量的推荐，它还提供了为何产生这种推荐的原因。</p><p>可解释模型解决的问题是：为什么算法会把这个对象推荐出来？</p><p>它面对的人群是用户或者系统的设计者，可以解决这两类人的疑惑</p><p>可解释模型可以用于改进推荐系统的透明度、可信度、满意度、效果。</p><p>本文对可解释的推荐进行了一个综合的回顾。本文将推荐问题分类为what、when、who、where、why，并且说明可解释的推荐在推荐系统研究中的位置。</p><p>本文从三个方面研究可解释的推荐系统：</p><ul><li>按时间顺序说明关于可解释推荐相关的研究</li><li>提供两个维度用于分类可解释的推荐研究：<pre><code>- 解释的信息源    - 产生可解释推荐的算法机制</code></pre></li><li>总结如何将可解释的推荐应用到不同的推荐任务上，比如商品推荐、社交推荐、POI（point of interest）推荐</li></ul><p>本文还对AI和ML领域的研究从可解释的角度进行讨论。最后，本文讨论了一些可以提升可解释推荐领域的研究方向。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Explainable-Recommendation"><a href="#Explainable-Recommendation" class="headerlink" title="Explainable Recommendation"></a>Explainable Recommendation</h3><p>可解释的推荐指的是解决了为什么问题的个性化推荐算法</p><p>个性化的推荐研究可以被分类到5W问题中：</p><ul><li>时间感知的推荐（time-aware）-&gt;when</li><li>基于位置的推荐（location-based）-&gt;where</li><li>社交推荐-&gt;who</li><li>应用感知的推荐（application-aware）-&gt;what</li><li>可解释的推荐-&gt;why</li></ul><p>可解释的模型可以分为：模型内嵌（model-intrinsic）、模型不相关（model-agnostic）[^Lipton,2018,the mythos][^Molnar,2019,interpretable]</p><ul><li>model-intrinsic：推荐模型的决策机制是透明的，可以知道其如何形成决策，自然就知道为什么会这样决策[^zhang,2014,explicit]</li><li>model-agnostic：决策过程可以不透明，使用一个用于生成解释的模型，在做出决策之后为其生成解释，这种方法也叫做因果颠倒法（post-hoc）[^wang,2018,a reinforcement learning][^Peak,2018,explanation mining]</li></ul><p>这两种方法是建立在人类的认知心理学基础上的：有时我们通过思考和推理自然地产生应该做的决定；有时我们先做决定，然后为这个决定找理由。</p><p>可解释推荐不仅仅要建立一个可解释的模型，同时还要建立一种将解释分发给用户的方法</p><h3 id="Historical-Overview"><a href="#Historical-Overview" class="headerlink" title="Historical Overview"></a>Historical Overview</h3><p>早期的个性化推荐系统主要是基于内容或者协同过滤CF，进行推荐[^Ricci,2011,Introduction to recommender]。</p><ul><li>基于内容（content-based）的推荐系统用各种内容信息，比如价格、品牌、颜色等来建模用户和项目[^Balabanovic,1997,Fab: content-based][^Pazzani,2007,content-based recommendation]，内容信息对于用户来说本来就很好理解，直接将被推荐的项目的这些信息告诉用户，就可以起到解释的作用。对于基于内容的推荐的解释的研究可以看[^Ferwerda,2012,Explaining Content-based]。收集用于建模的信息是很耗费时间的，这是该方法的弊端。</li><li>基于协同过滤（collaborative filtering，CF）的方法使用群体智能来解决收集信息耗时的问题[^Ekstrand,2011,collaborative filtering]。协同过滤推荐方法又可以分为两个方面：<pre><code>- 基于用户（user-based）的CF[^Resnick,1994,GroupLens]，这种方法用一个向量表示用户对于一个新闻的评级，对于那些没有评级的用户，使用其他用户的评级的加权平均来预测。（它基于的事实是，一个用户可能用到的东西是和他兴趣相同的其他用户用过的东西）- 基于项目（item-based）的CF[^Sarwar,2001,Item-based]，这种方法将项目的评分作为一个向量，使用相似的项目的加权平均来预测缺失的评分。亚马逊的商品推荐就属于基于项目的协同过滤[^Linden,2003,Amazon.com]（它基于的事实是，一个用户未来可能用到的东西是和他曾经用过的东西类似的东西）</code></pre></li></ul><p>协同过滤在可解释性上不像基于内容的方法这么直观，[^Herlocker,2000; Konstan,2000; Sinha,2002]这些文章研究了如何解释协同过滤方法。</p><p>后来，协同过滤方法和LFM（Latent Factor Model）结合起来，尤其是LFM中的MF（Matrix Factorization）取得了很好的效果[^Koren,2008; Koren,2009]。但是，LFM中的Latent Factor也没有直观的含义，可解释性弱。</p><p>可解释推荐问题这个名词最早是[^zhang,2014,Explicit factor models for explainbale recommendation]提出的，它用的模型是EFM。</p><p>深度学习模型是不是能提高推荐推荐系统的能力目前是存疑的[^Dacrema,2019,Are we really making]。</p><p>可解释问题在1980年就受到关注。Clancy说明了要对一个预测做出解释需要的知识比做出这个预测要多得多[^Clancy,1982,the epistemology]，最近可解释性问题又受到重视，人们希望解决广泛的领域里的AI可解释性问题，比如视觉的可解释性、NLP、自动驾驶的可解释性[^Gunning,2017,Explainable artificial]。</p><h3 id="Classification-of-the-methods"><a href="#Classification-of-the-methods" class="headerlink" title="Classification of the methods"></a>Classification of the methods</h3><p>为了分类现存的可解释模型，本文使用两个维度来区别分类：</p><ul><li>解释的展示方式（是用一句话表示解释？一张图表示解释？），这是从人机交互（HCI）方式的角度分类</li><li>产生解释的算法（近邻模型？矩阵分解？话题模型？图模型？深度学习？知识推理？关系规则挖掘？），这是从算法角度分类</li></ul><p>使用这两种方法进行分类模型，可以在表1.1中看到分类结果</p><h3 id="Explainability-and-Effectiveness"><a href="#Explainability-and-Effectiveness" class="headerlink" title="Explainability and Effectiveness"></a>Explainability and Effectiveness</h3><p>以往认为模型的有效性和可解释性是冲突的[^Ricci,2011,Introduction]。最近有证据表明这两个可能不冲突[^Biligic,2004,Explanation for recommender][^zhang,2014,Explicit]，比如深度表示学习既可以做到有效又可以做到可解释。</p><h3 id="How-to-Read-the-Survey"><a href="#How-to-Read-the-Survey" class="headerlink" title="How to Read the Survey"></a>How to Read the Survey</h3><p>进入这个领域需要有两个方面的知识：</p><p>1、推荐系统领域的知识</p><ul><li>Pazzani and Billsus，2007</li><li>Ekstrand et al., 2011</li><li>Shani and Gunawardana, 2011</li></ul><p>2、可解释性领域的知识</p><ul><li>Tintarev and Masthoff, 2007a</li><li>(Lipton, 2018; Molnar, 2019</li><li>Gunning, 2017; Samek et al., 2017</li></ul><h2 id="Information-Source-for-Explanations"><a href="#Information-Source-for-Explanations" class="headerlink" title="Information Source for Explanations"></a>Information Source for Explanations</h2><p>推荐的解释可以产生于不同的信息源并且用不同的方式进行表现[^Tintarev,2015,Explaining recommendations]，同一个推荐可以有不同的解释。</p><p>一些论文及其解释的表示方式：</p><ul><li>zhang2014a：用句子解释</li><li>Wu2015 和 zhang2015 和 kadry2014：用词云解释</li><li>chen2019b：用视觉图像解释</li><li>Sharma2013 和 Quijano2017：用社交关系解释</li><li>Herlocker2000 和 Bilgic2005 和 Tintarev2007b 和 McSherry2005：使用统计直方图或者饼图解释</li><li>Du2019：提供视觉分析方法</li></ul><h3 id="用相关用户或者对象进行解释"><a href="#用相关用户或者对象进行解释" class="headerlink" title="用相关用户或者对象进行解释"></a>用相关用户或者对象进行解释</h3><p>这个部分主要说明基于用户和基于项目的协同过滤的可解释性问题，因为采用这两种方法的推荐一般使用相关的用户或者对象进行解释。</p><ul><li><p>基于用户的协同过滤：找到和目标用户相似的用户，推荐他们喜欢的项目，该方法的解释性就是，因为目标用户和某一个群体用户相似，而且这个群体用户都对该项目的评价很好。Resnick1994讲了基于用户的协同过滤方法，Herlocker2000使用相似用户的评价的直方图或者相似用户的评价进行解释，如下图：</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200713225429.jpg" alt></p></li><li><p>基于项目的协同过滤：可以通过告诉用户被推荐的项目和他以前使用其他项目很相似达到解释的目的。Sarwar2001是关于使用基于项目的协同过滤。</p></li></ul><p>Tintarev2007开发了一个原型，用于研究添加解释到推荐系统的结果，他认为添加解释会带来七个好处：transpancy、scrutability、trustworthiness、effectiveness、persuasiveness、efficiency、satification，并且经过用户研究，确实会带来这样的好处。</p><p>一般来说，基于项目的解释比基于用户的解释可信，因为用户之前使用过相似的产品，而且，基于用户的解释可能会泄露用户的隐私，为了结局隐私问题，现在使用基于社交的解释替代基于用户的解释，[^Ren2017]和[^Tsai2018]就是使用这样的社交解释。</p><h3 id="基于特征的解释"><a href="#基于特征的解释" class="headerlink" title="基于特征的解释"></a>基于特征的解释</h3><p>基于特征的解释和基于内容的推荐方法有密切关系，基于内容的推荐中，系统匹配用户肖像和候选项目的内容特征进行推荐。Pazzani2007、Ferwerda2012、Cramer2008都是基于内容的推荐。</p><p>基于特征的解释可以有多种表现形式：</p><ul><li>标签解释方法：用项目的标签以及你对该标签的喜好程度进行解释。Vig2009就是一个电影标签进行推荐的例子。</li><li>雷达图解释法：用用户对各个方面的偏好和项目各个方面的能力的匹配程度进行推荐。Hou2018用雷达图解释。</li><li>用户人口统计学信息解释法：用用户的年龄、性别、住址信息进行推荐和解释，常常和社交媒体结合起来。Pazzani1999、Zhao2014、Zhao2016都是用人口统计学信息的方法。</li></ul><h3 id="基于观点的解释"><a href="#基于观点的解释" class="headerlink" title="基于观点的解释"></a>基于观点的解释</h3><p>现在人们可以对于项目进行评论，发表自己的观点。从这些观点中我们可以发现用户对一些方面的偏好，这些偏好可以用于推荐，也可以用于解释。McAuley2013、Zheng2017、zhang2014a、Li2017都是用这些观点进行推荐和解释。</p><p>基于观点的解释可以分为两种方法：</p><ul><li><p>方面级别的（aspects-level）：方面级别的解释和基于特征的解释很像，区别是，方面信息是从用户的评论中抽取出来的，特征则是人为规定有哪些特征。抽取方面信息和情感分析有关，Hu2004、Lu2011、Liu2012、Zhang2014b都是关于情感分析的。</p><p>尤其是Zhang2014b，这篇文章开发了一个toolkit叫Sentires，用于抽取“方面-观点-情感”三元组，在这个工具基础上，Zhang2014a、Wu2015、Ren2017、Wang2018b都是用于解释推荐的。</p></li><li><p>句子级别的：这个方法可以分为基于模板的句子和基于产生的句子</p><ul><li>模板句子法：定义一些句子的模板，比如“你对某某特征比较感兴趣，因此，你可能会喜欢某某商品”，特征是个性化得到的，用于后期填入。Zhang2014a、Wang2018b、Tao2019a、Gao2019都是模板方法。</li><li>自然语言产生技术：一般是使用LSTM等语言生成模型在评论数据上训练得到的。Costa2018、Chang2016、Li2017、Lu2018b、Chen2019a、Ni2019这些是使用语言模型的方法。</li></ul></li></ul><h3 id="视觉解释"><a href="#视觉解释" class="headerlink" title="视觉解释"></a>视觉解释</h3><p>视觉解释就是在图片中标明哪个部分是推荐给用户的的原因，这个方法通常要将用户的评论和图片的区域联系起来。Lin2019、Chen2019b都是有关视觉图片解释的。</p><h3 id="社交解释"><a href="#社交解释" class="headerlink" title="社交解释"></a>社交解释</h3><p>用和目标用户相似的用户解释一个推荐，可能并不是那么容易被理解，如果将用来解释的用户换成目标用户的朋友，那么就比较有说服力。</p><p>Facebook提供共同朋友作为推荐一个新的朋友的依据（Papadimitriou2012）；音乐推荐可以提供有多少朋友喜欢这个音乐（Sharma2013）；在商品推荐中指出和其有社交关系的人喜欢什么商品（Park2018）；将社交解释用于群推荐，提高接受程度和满意度（Quijano2017）；为了找到一个最有说服力的用户集合，采用两阶段排名算法找到这个集合（Wang2014）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>推荐解释的类型可以划分为六类：</p><ul><li>基于用户和项目的解释：和协同过滤有关</li><li>基于特征的解释：和基于内容的推荐有关</li><li>基于观点的解释：从用户评论中抽取观点，和情感分析有关</li><li>文本句子的解释：用模板或者自然语言处理方法处理文本句子</li><li>视觉解释：整张图片或者图片的一部分</li><li>社交解释：基于用户的社交关系的解释</li></ul><p>1-3类和推荐算法有关，4-6和如何展示解释有关。</p><h2 id="Explainable-Recommendation-Models"><a href="#Explainable-Recommendation-Models" class="headerlink" title="Explainable Recommendation Models"></a>Explainable Recommendation Models</h2><p>推荐的可解释性包含推荐方法的可解释性或者推荐结果的可解释性。推荐方法的可解释性就是模型生成推荐的过程是透明的，因此，形成的结果也就是可解释的。结果的可解释性是将模型视为一个黑箱，使用另外一个模型生成解释。</p><h3 id="Overview-of-Machine-Learning-for-Recommendation"><a href="#Overview-of-Machine-Learning-for-Recommendation" class="headerlink" title="Overview of Machine Learning for Recommendation"></a>Overview of Machine Learning for Recommendation</h3><p>一个传统的用于推荐的ML模型是LFM，它基于MF（矩阵分解）。矩阵分解的方法可以是SVD、NMF、MMMF、PMF、LMF。矩阵分解方法是一种逐点预测的方法。</p><p>成对学习用于学习正确的项目排名，基于隐含的反馈。Rendle2009提出BPR，用于学习购买的物品和未购买的项目的相对排名；Rendle2010进一步扩展张量分解的想法到模型成对交互；Shi2010采用列表学习为协同过滤排名。</p><p>使用深度学习的推荐方法有：</p><p>Cheng2016的Wide and Deep网络；Covington2016将DNN用于youtube推荐系统；Zheng2017的文本卷积网络；Chen2019b的图像卷积；Hidasi2016的基于用户行为的RNN；Wu2016的自动编码器；Chen2018c的记忆网络。</p><p>神经网络模型是否真的有效是有争议的，Dacrema2019提出这个问题。Zhang2019认为只要可用于训练的数据足够多，深度模型就有效。</p><h3 id="Factorization-Models-for-Explainable-Recommendation"><a href="#Factorization-Models-for-Explainable-Recommendation" class="headerlink" title="Factorization Models for Explainable Recommendation"></a>Factorization Models for Explainable Recommendation</h3><p>采用矩阵分解的可解释推荐模型，使用低维的向量表示用户和项目，表示向量的每个维度代表一个特定的可以影响用户决定的因素，但是，我们并不能直观的知道这些因素的含义是什么，因此，利用这些进行解释是很困难的。</p><p>为了解决这个问题，zhang2014a提出EFM，这个方法的想法是，从用户对产品的评论中获得产品的特征，以及用户喜欢的特征，是否为用户推荐这个产品，就看两者的特征是不是匹配了，这个模型将特征和矩阵分解的维度进行对齐，这样推荐的过程就变得可解释了。如下图：</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200713225523.jpg" alt></p><p>用户对某些特征的喜好是会随着时间改变的，为了适应这种改变，zhang2015b提出了能够动态建模用户特征的方法。</p><p>chen2016将EFM扩展到张量分解，这个模型从评论中抽取产品特征，构成用户-产品-特征的三维矩阵，在这个矩阵上执行成对学习，来预测用户对特征和产品的偏好，继而提供推荐。如下图：</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200713225627.jpg" alt></p><p>Wang2018b利用张量上的多任务学习进行推荐，一个是推荐任务，一个是解释任务，这个算法分别计算用户在某个产品属性上的观点向量，再计算产品在某个属性上的观点向量，两者相乘，得到是否应该推荐这个产品，以及为何推荐它。如下图：</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200713225642.jpg" alt></p><p>在不同的产品上，用户对于属性的偏好分布是不同的（比如，对于衣物和电脑这两种商品，用户关注的属性就是不一样的，对于衣物，用户比较关心外观，对于电脑，用户可能比较关注性能参数），但是之前的方法假设的都是用户在不同的产品上有相同的特征偏好分布。chen2018b提出AFM使用注意力机制调整用户注意力的分布，解决这个问题。</p><p>为了分析LFM模型中输入和输出的关系，cheng2019a采用影响分析方法，追溯每个预测到训练数据中，提供直观的邻居形式的解释。</p><p>从评论中抽取的特征也可以作为推荐的对象，Bauman2017提出的SULM，这个模型抽取特征以及用户在这些特征上的情感，它将特征和情感整合到矩阵分解模型中，用它回归未知评分的项目，最终提供不仅仅是项目的推荐，同时也是特征的推荐。比如，推荐一个餐厅的同时可以为你推荐就餐时间、菜品等等。Qiu2016和Hou2018也差不多。</p><p>为了获得更好的推荐和解释，可以在LFM模型中增加树形或者图结构数据，Tao2019a使用了因式分解树结构数据，用于解释，该树形结构中的路径就是对结果的一种解释。</p><p>产生相关用户或者相关项目的解释，现有如下方法：</p><ul><li>Abdollahi2016、2017提出EFM，它的解释方法是“很多和你相似的用户都购买它”，该模型添加一个解释正则项到矩阵分解的目标函数中，使得用户的潜在向量和项目的潜在向量在很多邻居用户都购买它时变得很相似。</li><li>Liu2019，提出一个可解释的概率因式分解模型，应用影响机制，评价用户历史数据的重要性，用最相关的用户和项目去解释。它将用户或者项目分为五组：有影响的用户、容易被影响的用户、独立的用户、流行的项目、长尾的项目，它产生的解释是“推荐该项目是因为一个有影响力的用户也在使用它”</li></ul><h3 id="Topic-Modeling-for-Explainable-Recommendation"><a href="#Topic-Modeling-for-Explainable-Recommendation" class="headerlink" title="Topic Modeling for Explainable Recommendation"></a>Topic Modeling for Explainable Recommendation</h3><p>话题模型是用于处理大量的文本类型的评论的，它的可解释性主要通过话题词云的形式展现。</p><p>McAuley2013提出HFT模型，它在LFM模型和LDA之间搭建了一座桥，它将隐藏向量的维度和LDA的维度联系起来，这样可以理解为何用户对目标项目如此评分，同时知道用户喜欢的最重要的话题。</p><p>Tan2016提出在同一个语义空间中建模项目和用户的偏好，之后使用LFM得到推荐，对于推荐有重要作用的话题词可以被当做解释。如下图：</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200713225706.jpg" alt></p><p>cheng2019b采用多种形式的数据丰富话题模型，比如不仅仅考虑文本形式的评论，还考虑产品的图片，它可以从不同的角度学习用户的喜好和项目的特征，并且知道哪个方面的特征比较重要，把它作为推荐。</p><p>Wu2015提出FLAME，它学习每个用户在项目不同方面的偏好（比如某一家餐馆的位置、干净程度、服务等），通过协同过滤学习一个用户在新的项目各个方面上的评分，提供解释的时候就把那些方面用词云的形式表现出来（如果这个方面评分高的话，词云中的词就比较大）。如下图：</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200713225725.jpg" alt></p><p>Zhao2015设计了一个可以整合情感、方面、区域的框架，用它来进行POI推荐，每个用户的话题方面的喜好决定了如何解释。</p><p>Ren2017提出sCVR，使用“viewpoint”进行解释，“viewpoint”是一个元组，由概念、话题、情感组成。</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200713225743.jpg" alt></p><h3 id="Graph-based-Models-for-Explainbale-Recommendation"><a href="#Graph-based-Models-for-Explainbale-Recommendation" class="headerlink" title="Graph-based Models for Explainbale Recommendation"></a>Graph-based Models for Explainbale Recommendation</h3><p>很多的用户-用户关系、用户-项目关系可以被视为图结构数据，尤其是在社交网络场景，因此，可解释的推荐可以基于图学习方法生成。</p><p>He2015引入三部分图结构建模用户-项目-方面关系，其中，方面指的是从用户评论中抽取的项目的特征，该工作还使用TriRank为图的顶点排序，解释是使用排名最高的方面进行解释。</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200713225757.jpg" alt></p><p>不使用外部的信息，比如方面信息，Heckel2017在用户的-项目二部图上执行聚合算法，每个聚类中的用户有相似的属性，它的解释是“项目a被推荐给用户x，是因为x曾经购买过b、c、d三种项目，而具有相同的购买历史的用户y、z也都购买了a”。如下图（图中颜色相同的是有相同购买历史的用户聚合）：</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200713225809.jpg" alt></p><p>Wang2018c将基于嵌入的模型和基于树形的模型结合在一起，基于树形的模型具有良好的解释性，基于嵌入的模型泛化能力良好，可以用于没有见过的用户和项目。</p><p>Park2018提出UniWalk算法，这是基于图的可解释推荐算法，它将产品评分和社交网络结合，产生可解释的推荐。解释是使用和目标用户有相同偏好的朋友进行解释。</p><h3 id="Deep-Learning-for-Explainable-Recommendation"><a href="#Deep-Learning-for-Explainable-Recommendation" class="headerlink" title="Deep Learning for Explainable Recommendation"></a>Deep Learning for Explainable Recommendation</h3><p>Seo2017提出一个使用CNN建模用户偏好以及项目属性的模型，它使用的素材是评论文本，在解释的时候，它使用了局部和全局的注意力，当进行预测时，模型选择评论词汇，并且赋予不同注意力权重，模型可以知道评论的那个部分比较重要，这些部分可以用于解释。</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200713225830.jpg" alt></p><p>Wu2019将用户和项目的交互以及评论信息整合到统一的框架中。Lu2018a使用MF方法到评分上，使用基于注意力的GRU到评论数据上。Lu2018b添加了一个评论鉴别器，基于对抗s2s学习，因此，生成器可以产生评论，这个评论可以用于解释。</p><p>Gao2019提出DEAML用于缓解推荐精确度和可解释性之间的冲突，基本的想法是构建一个基于可解释的深度层级架构，这个模型可以建模多层特征。</p><p>Ma2019a提出可以自动学习从数据中分离出来的特征，它能够让用户控制推荐的结果。</p><p>Costa2018提出一个基于字符级RNN的方法，用于自动产生自然语言的解释，选择不同的参数，模型可以产生不同的解释。如图：</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200713225849.jpg" alt></p><p>Li2017提出一个更加综合的模型去产生小贴士，这些贴士是对长评的总结。</p><p>Chen2019a将自然语言方法和特征词方法整合在一块，提出话题敏感的生成模型，为特定的特征词生成解释，模型可以控制解释是对那个方面的解释。</p><p>Chen2019d提出编码-选择-解码的架构，用于推荐解释，它探索了推荐任务和解释任务之间的相关性，使用共同注意力多任务学习。</p><p>Chang2016提出一个基于人类用户和众包的自然语言产生方法，他们首先使用无监督学习方法抽取电影评论的话题，之后为话题产生自然语言解释，具体是作者为每个话题收集相关的评论，然后让众包工人综合评论生成解释，最后，通过他们的活动建模他们的偏好。</p><p>Chen2018a不是生成解释，而是从用户评论中选择一个合适的作为解释，作者引入注意力机制去学习评论的有效性。</p><p>Chen2019b提出了一个结合了视觉图像和评论文本的模型，它既可以在图片中强调感兴趣的区域，又可以为感兴趣的区域生成解释。</p><p>Chen2018c研究了基于记忆网络的序列推荐模型，它将用户历史中的项目作为记忆模块，在模块上使用注意力机制，进行预测后续的行为。</p><p>Chen2019c提出动态可解释推荐，基于时间注意的GRU。</p><p>Tao2019b提出Log2Intent，它用于建模用户行为。</p><p>Li2019开发了一个胶囊网络，它考虑项目-用户对作为逻辑单元，逻辑单元是从评论中发掘出来的。</p><p>深度学习模型有时候不能决定模型产生的解释是不是真的反映了真实的产生推荐的机制。Jain2019认为注意力模型没有提供有意义的解释；Wiegreffe2019认为之前的工作没有证明注意力机制对于解释的有效性。</p><h3 id="Knowledge-Graph-based-Explainable-Recommendation"><a href="#Knowledge-Graph-based-Explainable-Recommendation" class="headerlink" title="Knowledge Graph-based Explainable Recommendation"></a>Knowledge Graph-based Explainable Recommendation</h3><p>Catherine2017提出同时为项目和知识图谱中的实体排序的方法，使用的是个性化的PageRank，实体是作为解释用的。</p><p>Ai2018提出使用知识图谱嵌入作为可解释推荐，该工作使用用户-项目知识图谱，模型为每个用户和项目生成一个嵌入，推荐的是和用户之前购买的项目相似的项目，解释可以使用用户和推荐项目的最短路表示。如下图：</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200713225902.jpg" alt></p><p>Wang2018a提出一个RippleNet，模拟水面的波纹的传播，用来传播用户的偏好，最终可以预测点击的概率，解释可以通过知识图谱中的路径表示。</p><p>Huang2018将RNN和KV-MN结合起来，用于序列推荐，RNN是用于捕捉用户关于项目的偏好，记忆网络通过项目的知识图捕捉用户基于属性的偏好，最后，序列的偏好和属性偏好被结合起来作为最后用户偏好的表示。</p><p>Huang2019进一步包含多种形式的知识图到推荐模型中，这个方法可以捕捉用户动态的偏好。</p><p>Ma2019b提出的框架整合了知识图谱的规则归纳以及一个规则引导的神经推荐模型，一个模型基于的是从知识图中挖掘出来的规则（用于表示项目之间的关系），另一个模型用于推荐。</p><p>真实的知识图是很大的，计算开销很大，Xian2019提出一个强化学习的方法，用于路径查找，这样就避免了枚举所有用户-项目路径再比较相似性了。</p><h3 id="Rule-Mining-for-Explainable-Recommendation"><a href="#Rule-Mining-for-Explainable-Recommendation" class="headerlink" title="Rule Mining for Explainable Recommendation"></a>Rule Mining for Explainable Recommendation</h3><p>规则挖掘在可解释推荐上具有天然的优势，因为这些抽取出来的规则就可以作为解释的一部分</p><p>主要用于可解释推荐的规则挖掘是<strong>关联规则挖掘</strong>，Agrawal1993、1994是关于规则挖掘的文章</p><p>使用关联规则挖掘进行推荐的文章有：</p><ul><li>Mobasher2001：网页推荐</li><li>Cho2002：结合了决策树，进行网页商店推荐</li><li>Smyth2005：会话推荐任务</li><li>Sandvig2007：研究协同推荐的鲁棒性</li><li>Zhang2015a：对浏览器日志使用频率模式挖掘进行推荐</li><li>Amatriain2015：一篇关于将数据挖掘用于推荐系统的文章</li></ul><p>在可解释性推荐方面的关联规则方式的使用有一下文章：del </p><ul><li>Lin2000、2002：提出针对特定用户的关联规则，即个性化关联规则</li><li>Davidson2010：介绍了Youtube的视频推荐，方法大概是，对一段时间的观看数据进行挖掘，统计每对影片的相关程度，将用户最近看过的，或者喜欢的电影作为种子，将和该种子相关性高的电影推荐给用户，这种相关性就可以作为推荐的解释</li><li>Balog2019：一种基于集合的方法，解释是句子形式的</li></ul><h3 id="Model-Agnostic-and-Post-Hoc-Explainable-Recommendation"><a href="#Model-Agnostic-and-Post-Hoc-Explainable-Recommendation" class="headerlink" title="Model Agnostic and Post Hoc Explainable Recommendation"></a>Model Agnostic and Post Hoc Explainable Recommendation</h3><p>如果产生推荐的机制非常复杂，那么无法从如何产生推荐这个角度进行解释了，此时，可以将产生推荐的模块和产生解释的模块分开来，先产生推荐，再根据产生的推荐生成解释，这种方式被称为事后解释（Post Hoc）或者模型不相关方法。</p><p>常见的事后解释方式是使用一些统计信息进行解释，统计信息则是通过关联规则挖掘得到的，表现形式是将这些信息添加到事先定义好的句子模板中。</p><p>事后解释的相关论文有：</p><ul><li>Peake and Wang2018：将推荐模型视为一个黑箱，使用推荐模型的输入和输出抽取关联特征，通过这些关联特征进行解释</li><li>Singh and Anand2018：研究的是排名算法的事后解释</li><li>Ribeiro2016：其中心思想是使用简单的模型近似复杂的模型，他提出LIME，采用稀疏的线性模型来近似复杂的模型，线性模型可以向我们解释样本的哪个属性对于预测结果有重要作用</li><li>Singh and Anand2019：使用LIME对排名算法进行解释</li><li>McInerney2018：其提出bandit方法，该文章认为，用户对于解释的态度是动态的，对于不同的用户，给的解释不能相同，如何选择一个合适该用户的解释，是一个问题</li><li>Wang2018d：提出一个强化学习框架，用于为推荐产生句子级别的解释</li><li>Cheng2019a：提出FIA方法，使用因素分析（influence analysis）方法解释推荐，这是一种数学上的理解</li></ul><p>总的来说，事后的解释（post-hoc）的优点在于它可以适用很多推荐模型，因为它另外构造了一个解释模型，缺点就是解释的可信度有限。</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>推荐系统的解释性主要是从两个方面入手，一个是推荐过程的可解释性，一个是推荐结果的可解释性，其代表了两种认知科学的观点，一种是通过逐步推理做出决定，一种是直觉的做出决定，再回头寻找理由。Lipton2018和Miller2019对这种认知科学进行了解释。</p><h2 id="Evaluation-of-Explainable-Recommendation"><a href="#Evaluation-of-Explainable-Recommendation" class="headerlink" title="Evaluation of Explainable Recommendation"></a>Evaluation of Explainable Recommendation</h2><p>我们所追求的理想的可解释推荐系统是，在推荐方面要超过非可解释推荐系统，同时在可解释性方面要更好。</p><p>为了进行比较，需要定义一系列的比较方法，在推荐方面的评价方式有：</p><ul><li>对于评分预测类型的推荐：平均绝对误差（MAE）、开方均方误差（RMSE）</li><li>对于top-n类型的推荐：精度、召回率、F-measure、NDCG、在线测量点击率或者转化率</li></ul><p>在可解释性比较方面：</p><p>有在线比较和离线比较方式，离线比较容易实现，在线比较不是必须</p><h3 id="User-Study"><a href="#User-Study" class="headerlink" title="User Study"></a>User Study</h3><p>用户调研主要指的使用众包网站，发布调查问卷，调查人们对于推荐解释的满意程度，并以此作为评价一个可解释推荐的标准。常用的众包网站有AMT、CrowdFlower。</p><h3 id="Online-Evaluation"><a href="#Online-Evaluation" class="headerlink" title="Online Evaluation"></a>Online Evaluation</h3><p>在线评价其实就是把模型放到实际的网站上，比如购物网站，通过分析用户的点击率（CTR）或者用户最终购买商品的比例（转化率），用于评价对于推荐的解释是不是有效的。这种方法和User Study都是在网上进行的，他们之间的不同是User Study中被调查的人是知道自己正在做一个推荐系统的调查，这样可能不能完全反应其真实状况，而在线评价是在用户未知的情况下进行的。</p><h3 id="Offline-Evaluation"><a href="#Offline-Evaluation" class="headerlink" title="Offline Evaluation"></a>Offline Evaluation</h3><p>离线的可解释推荐效果评价主要有两种方法，一种是推荐可以被解释模型解释的百分比，另一种是解释的质量。</p><ul><li>可以被解释模型解释的推荐占的百分比：MEP、MER、Fidelity</li><li>评价解释的质量：BLEU、ROUGE、Lin（这三个方法都是评价生成的解释和标的的解释是否相似的）； Gunning Fog Index 、Flesch Reading Ease 、Flesch Kincaid Grade Level 、 Automated Readability Index、 Smog Index （这些评价方式是评价解释的可读性的）</li></ul><h3 id="Qualitative-Evaluation-by-Case-Study"><a href="#Qualitative-Evaluation-by-Case-Study" class="headerlink" title="Qualitative Evaluation by Case Study"></a>Qualitative Evaluation by Case Study</h3><p>个案分析是通过分析某个用户和被推荐项目之间的相似性达到的，可以通过雷达图进行表示，在图上可以看到用户关注的东西和被推荐的东西之间的相似性。</p><h2 id="Explainable-Recommendation-in-Diﬀerent-Applications"><a href="#Explainable-Recommendation-in-Diﬀerent-Applications" class="headerlink" title="Explainable Recommendation in Diﬀerent Applications"></a>Explainable Recommendation in Diﬀerent Applications</h2><p>本节主要盘点可解释推荐在不同场景下的应用</p><h3 id="Explainable-E-commerce-Recommendation"><a href="#Explainable-E-commerce-Recommendation" class="headerlink" title="Explainable E-commerce Recommendation"></a>Explainable E-commerce Recommendation</h3><p>应用在电子商务推荐的论文包括：</p><ul><li>Zhang2014a：JD推荐</li><li>He2015：电子产品推荐</li><li>Chen2016：一种排名算法，用于跨类别推荐</li><li>Seo2017和Wu2019：Amazon推荐</li><li>Heckel2017：可扩展、解释的产品推荐</li><li>Chen2019b：可视化的解释，用于流行产品推荐</li><li>Hou2018：用于电子游戏产品推荐（Amazon）</li><li>Chen2018a：对评论进行神经注意力回归（Amazon）</li><li>Chen2018c：使用记忆里网络进行序列化推荐（Amazon）</li><li>Wang2018b：多任务学习（Amazon）</li><li>Ai2019：可解释的产品搜索</li></ul><p>如果把可解释的推荐意义提高，则可以认为是在实现社会责任推荐</p><h3 id="Explainable-Point-of-Interest-Recommendation"><a href="#Explainable-Point-of-Interest-Recommendation" class="headerlink" title="Explainable Point-of-Interest Recommendation"></a>Explainable Point-of-Interest Recommendation</h3><p>所谓POI推荐，一般都是位置推荐，比如酒店位置、餐厅位置、博物馆位置等等，一般使用的数据集是Yelp、TripAdvisor</p><p>关于POI推荐的论文主要有：</p><ul><li>Wu and Ester2015</li><li>Bauman2017</li><li>Seo2017</li><li>Zhao2015</li><li>Wang2018c</li><li>Baral2018</li></ul><h3 id="Explainable-Social-Recommendation"><a href="#Explainable-Social-Recommendation" class="headerlink" title="Explainable Social Recommendation"></a>Explainable Social Recommendation</h3><p>社交推荐一般包括朋友推荐、新闻推荐、音乐推荐、博客推荐、网页推荐、图片推荐，只要是社交环境中的推荐都算是推荐。</p><p>相关的论文主要有：</p><ul><li>Bountouridis2018：关于新闻可信度研究</li><li>Ren2017：社交推荐</li><li>Quijano2017：组推荐</li><li>Tsai2018：社交推荐</li></ul><h3 id="Explainable-Multimedia-Recommendation"><a href="#Explainable-Multimedia-Recommendation" class="headerlink" title="Explainable Multimedia Recommendation"></a>Explainable Multimedia Recommendation</h3><p>多媒体推荐的应用主要体现在书籍推荐、新闻推荐、音乐推荐、电影推荐、视频推荐，经常使用MovieLens数据集，相关论文主要有：</p><ul><li>Abdollahi and Nasraoui2016、2917：使用的是矩阵因式分解</li><li>Chang2016：使用众包生成自然语言解释</li><li>Lee2018：多个方面的解释电影推荐</li><li>Catherine2017：使用知识图谱进行电影推荐</li><li>Wang2018a：使用波纹网络在知识图谱上传递用户偏好，用于多媒体推荐</li><li>Zhao2019a：研究的是微软小冰的可解释歌曲推荐</li><li>Davidson2010：使用关联规则挖掘解释YouTube的视频推荐</li><li>Kraus2016：研究新闻推荐的可解释性</li></ul><h3 id="Other-Explainable-Recommendation-Applications"><a href="#Other-Explainable-Recommendation-Applications" class="headerlink" title="Other Explainable Recommendation Applications"></a>Other Explainable Recommendation Applications</h3><p>可解释推荐还能应用在其他的方面，比如学术推荐、引用推荐、法律推荐、医疗保健推荐等等。相关的论文包括：</p><ul><li>Gao2017：研究在线医疗保健论坛中的可解释文本分类</li><li>Liu2018：研究健康监测中的离群点可解释监测</li><li>Singh2019：可解释搜索</li><li>Zhao2019b：问答系统</li><li>Bountouridis2018：新闻可信度分析</li></ul><h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3><p>并不是所有的推荐都需要或者说适合提供解释，比如，如果推荐的内容是time-critical（时序严格的），那么需要在尽快的时间内做出决定，而不是倾听解释来验证决定的正确性</p><h2 id="Open-Directions-and-New-Perspectives"><a href="#Open-Directions-and-New-Perspectives" class="headerlink" title="Open Directions and New Perspectives"></a>Open Directions and New Perspectives</h2><p>在这个部分主要说明目前可解释推荐的一些研究方向和新的研究角度。</p><h3 id="Explainable-Deep-Learning-for-Recommendation"><a href="#Explainable-Deep-Learning-for-Recommendation" class="headerlink" title="Explainable Deep Learning for Recommendation"></a>Explainable Deep Learning for Recommendation</h3><p>研究人员比较关注开发可解释的深度学习模型用于可解释的推荐，当前的方式主要是设计出能同时产生推荐和解释的深度模型。解释主要来源于注意力权重。在很多情况下，深度学习是一个黑箱主要原因是隐藏层没有拥有直观的含义。</p><ul><li>Koh2017：提出基于影响分析对深度神经网络进行分析</li><li>Pei2017：提出白盒测试机制用于帮助理解深度学习系统</li></ul><h3 id="Konwledge-enhanced-Explainable-Recommendation"><a href="#Konwledge-enhanced-Explainable-Recommendation" class="headerlink" title="Konwledge-enhanced Explainable Recommendation"></a>Konwledge-enhanced Explainable Recommendation</h3><p>如果推荐系统能知道关于推荐领域的特定知识，那么就可以产生更具有说服力的解释和推荐，比方说在电影推荐中，知道演员和导演的知识。随着知识图谱嵌入技术的发展，将图嵌入和推荐模型结合起来，这样做出的推荐就可以利用特定的领域知识了，同时，这样还可以构建对话式的推荐系统。</p><h3 id="Multi-Modality-and-Heterogenous-Information-Modeling"><a href="#Multi-Modality-and-Heterogenous-Information-Modeling" class="headerlink" title="Multi-Modality and Heterogenous Information Modeling"></a>Multi-Modality and Heterogenous Information Modeling</h3><p>在搜索和推荐中，常常使用的数据是多种形式，来源于多种信息源的，比如文档、图片、音频、视频等等，这类信息称为异质化信息，为了面对这些信息，需要研究跨领域信息的对齐和抽取。</p><h3 id="Context-aware-Explanations"><a href="#Context-aware-Explanations" class="headerlink" title="Context-aware Explanations"></a>Context-aware Explanations</h3><p>由于用户的偏好、项目的属性是动态变化的，会随着环境的改变而改变，因此，对用户的推荐以及推荐的解释也应该要动态变化，但是，当前的很多可解释推荐模型都是静态的，都是相对数据集来说的，而不是实际。</p><h3 id="Aggregation-of-Different-Explanations"><a href="#Aggregation-of-Different-Explanations" class="headerlink" title="Aggregation of Different Explanations"></a>Aggregation of Different Explanations</h3><p>为了不同的目的，通常需要产生不同的解释，那么，如何选择和组织这些解释，让它们形成一个逻辑统一的解释，是很总要的，也是一个研究的方向。</p><h3 id="Explainable-Recommendation-as-Reasoning"><a href="#Explainable-Recommendation-as-Reasoning" class="headerlink" title="Explainable Recommendation as Reasoning"></a>Explainable Recommendation as Reasoning</h3><p>推理过程透明的模型一般效果不太好，效果好的一般不透明，因此，如何将两者结合起来，将协同过滤变成协同推理，是解决这个矛盾的一种方式。</p><h3 id="NLP-and-Explainable-Recommendation"><a href="#NLP-and-Explainable-Recommendation" class="headerlink" title="NLP and Explainable Recommendation"></a>NLP and Explainable Recommendation</h3><p>比较自然的解释应该是自然语言的解释，而不是基于模板句子的解释，这种解释称为free-text解释。</p><p>对于NLP解释的一个简单想法就是训练一个语言生成模型，使用NLP生成解释仍然处于初级阶段，需要解决的问题有，如何去除评论中和解释无关的东西、如何个性化的生成解释、如何生成混合的解释（混合了图片等等的）</p><h3 id="Answering-the-Why-in-Conversations"><a href="#Answering-the-Why-in-Conversations" class="headerlink" title="Answering the Why in Conversations"></a>Answering the Why in Conversations</h3><p>推荐的解释按照给出的形式可以分为主动获得、被动获得，一般电子商务的商品推荐的解释都是被动获得的，因为它在给出推荐的时候顺便给出了解释，对于主动得到的解释，有一个例子，微软小冰的歌曲推荐，微软小冰会在你需要解释的时候给你解释。</p><h3 id="Evaluation-of-Explainable-Recommendations"><a href="#Evaluation-of-Explainable-Recommendations" class="headerlink" title="Evaluation of Explainable Recommendations"></a>Evaluation of Explainable Recommendations</h3><p>评价一个可解释推荐系统的解释性是一个难题，尤其是离线评价可解释性，而且，对于不同角度的可解释性的评价方式也是不一样的。</p><h3 id="User-Behavior-Perspectives"><a href="#User-Behavior-Perspectives" class="headerlink" title="User Behavior Perspectives"></a>User Behavior Perspectives</h3><p>推荐系统其实属于一种人机交互系统，因此，对于用户的行为进行分析，可以有助于评价一个系统的性能</p><h3 id="Explanation-for-Broader-Impects"><a href="#Explanation-for-Broader-Impects" class="headerlink" title="Explanation for Broader Impects"></a>Explanation for Broader Impects</h3><p>目前，解释一般用来说服用户相信一个推荐，但是，解释还有很多其他的影响，比如改善信任程度、有效性、多样性、满足感、公平性等等。</p><h3 id="Cognitive-Science-Foundations"><a href="#Cognitive-Science-Foundations" class="headerlink" title="Cognitive Science Foundations"></a>Cognitive Science Foundations</h3><p>关于可解释推荐或者可解释的AI，有两种研究哲学，一种是构建透明的模型，展示生成推荐的每个过程，另一种是先生成推荐，再寻求解释；这两种到低哪种是对的，是一个研究的方向。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>解释性的缺乏主要存在两个方面，一是推荐系统的输出结果对于用户来说解释性缺乏；二是推荐模型的机制对于系统设计者来说解释性缺乏。</p>]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Explainable Recommendation </tag>
            
            <tag> Paper_Reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建过程</title>
      <link href="/2020/07/01/construct-the-blog/"/>
      <url>/2020/07/01/construct-the-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-搭建过程"><a href="#Hexo-搭建过程" class="headerlink" title="Hexo 搭建过程"></a>Hexo 搭建过程</h1><p>记录这个部落格搭建的点点滴滴~~</p><p>主要参考Hexo官方教程，<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">教程地址</a></p><h2 id="已加入功能"><a href="#已加入功能" class="headerlink" title="已加入功能"></a>已加入功能</h2><ul><li>看板娘</li><li>访客地图</li><li>Gitalk评论</li><li>在线聊天</li><li>网易云音乐</li><li>本地搜索</li><li>友链</li><li>站点背景彩带和网格</li><li>网站统计</li><li>打字抖动效果</li><li>聊天式的关于我</li><li>申请新的域名并绑定 <a href="http://www.yoyoghurt.cool/" target="_blank" rel="noopener">http://www.yoyoghurt.cool/</a></li><li>图片采用图床存储，并cdn加速访问</li><li>添加相册</li><li>添加豆瓣个人主页</li></ul><h2 id="未来加入功能"><a href="#未来加入功能" class="headerlink" title="未来加入功能"></a>未来加入功能</h2><ul><li>添加点击发出音乐特效</li><li>日历</li><li>更多友链</li><li>PWA</li><li>数学公式支持</li><li>网站分析统计</li><li>字体特效</li><li>友情链接边框特效</li><li>关于我聊天窗口样式优化</li><li>鼠标样式优化</li></ul><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>Hexo是一个博客框架，它可以将Markdown语法表示的文章生成静态网页。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>需要安装Git和Node.js，Node.js的安装包位于<a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a>，安装Node.js时一定要选择把路径添加到环境中。接着安装Hexo，可以使用npm包管理下载安装hexo，在安装Node.js时npm也会被安装。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>该命令将hexo安装到当前用户目录下的AppData\Roaming\npm\node_modules文件夹中。</p><h2 id="建立部落格"><a href="#建立部落格" class="headerlink" title="建立部落格"></a>建立部落格</h2><h3 id="建立blog存放的文件夹，并使用hexo进行初始化"><a href="#建立blog存放的文件夹，并使用hexo进行初始化" class="headerlink" title="建立blog存放的文件夹，并使用hexo进行初始化"></a>建立blog存放的文件夹，并使用hexo进行初始化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init 【目标目录】#初始化该目录为blog存放目录</span><br><span class="line">npm install#在该目录下安装npm包管理，会新生成node_modules目录</span><br></pre></td></tr></table></figure><p>所有文件包括</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200709172741.png" alt></p><h3 id="本地预览blog"><a href="#本地预览blog" class="headerlink" title="本地预览blog"></a>本地预览blog</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s//在blog目录下运行该命令打开本地服务端s-&gt;serve，可以使用     //localhost:4000/访问</span><br><span class="line">hexo s -p 【端口号】 //如果4000端口冲突，那么改为使用别的端口</span><br></pre></td></tr></table></figure><p>在预览前通常需要生成 <code>hexo generate</code></p><h3 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h3><p>站点目录下的_config.yml文件为站点配置文件，这个需要区别主题配置文件</p><ul><li>title 主标题</li><li>subtitle 副标题</li><li>description 用于展示给搜索引擎的网站描述</li><li>keywords 关键词，逗号分隔</li><li>language 网站的语言，中文为zh-CN</li><li>timezone 网站时区，默认为电脑时区</li><li>theme 设置使用哪个主题</li><li>new_post_name 设置新建文档时文档的文件名，但是并不是显示在页面上的文章的标题，为了方便管理文件，可以将其设定为 :year-:month-:day-:title.md，这样可以方便根据文件名称知道文件建立的信息</li><li>post_asset_folder 用于设置是否在创建文章时同时创建文章资源目录，如果同时创建，那么可以使用相对路径引用资源文件</li></ul><h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new 【文章标题】</span><br></pre></td></tr></table></figure><p>该命令在source \ _posts目录下生成一个以文章标题为名的.md文件，在该文件中可以编辑这个文章的内容，如果希望生成的文件的文件名不是文章标题，可以配置配置文件中的new_post_name参数实现</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>该命令将博客的内容生成HTML文件，这些文件放在public目录下，此后就可以进行本地预览或者部署到远程了</p><p>【注意】执行该命令时，文章的头部信息冒号后要加空格，否则generate会出错，如下图所示</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200709174510.png" alt></p><center>未加空格报错</center><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200709174551.png" alt></p><center>错误信息</center><p>加上空格后不会出错</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200709174620.png" alt></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new draft 【文章的名字】</span><br></pre></td></tr></table></figure><p>该命令在source \ _drafts目录下生成草稿文件，这个草稿文件在本地预览的时候是不会显示出来的，因此，草稿功能可以用于一下几种情况：</p><ul><li>文章还没有写好，不想让别人看到</li><li>文章想要丢弃，但是舍不得彻底删掉</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s --drafts</span><br></pre></td></tr></table></figure><p>该命令可以让草稿也被预览</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo publish 【草稿名称】</span><br></pre></td></tr></table></figure><p>该命令可以将草稿复制到source \ _posts目录中，使得草稿得以在浏览器中显示，本质上是一个复制的过程</p><h3 id="在文章中插入图片"><a href="#在文章中插入图片" class="headerlink" title="在文章中插入图片"></a>在文章中插入图片</h3><p>在md文件中插入图片有两种方法，一种是使用source/img目录下的路径，另一种是使用文章资源目录存放图片，并用相对目录引用</p><ul><li><p>传统方式</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](img/图片名称.xxx)</span><br></pre></td></tr></table></figure><p>这种方法是不会在md文件中显示图片的，但是可以在预览中看到</p></li><li><p>使用相对路径</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>设置允许创建文章资源目录</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](图片名称.xxx)#markdown语法形式表示</span><br><span class="line">&#123;%asset_img 【图片名称】 【图片描述】%&#125;#使用标签语言表示</span><br></pre></td></tr></table></figure><p>如果采用标签语言表示的话，需要为hexo安装图片显示插件，安装方式如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure></li><li><p>使用在线图床的外链，这个链接可以在本地也显示出图片来</p></li></ul><h2 id="Butterfly主题使用"><a href="#Butterfly主题使用" class="headerlink" title="Butterfly主题使用"></a>Butterfly主题使用</h2><p>该主题的官方教程<a href="https://demo.jerryc.me" target="_blank" rel="noopener">猛戳这里</a></p><h3 id="获得该主题"><a href="#获得该主题" class="headerlink" title="获得该主题"></a>获得该主题</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>该主题需要安装Pug和stylus两个渲染器，安装如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h3 id="设置使用该主题"><a href="#设置使用该主题" class="headerlink" title="设置使用该主题"></a>设置使用该主题</h3><p>在站点目录下的_config.yaml文件中设置theme标签为主题名称（主题文件夹的名称）</p><ol><li><p>配置文件的类型</p><p>该主题的配置文件有两种：一种是hexo根目录下的 _config.yml，这个称为站点配置文件；另一种是主题文件夹下的配置文件 _config.yml 。</p><p>为了在升级主题时方便，不至于丢失以往对主题的设置，可以将主题的配置文件放在 source \ _data目录下（通常命名为主题名.yml），这样新的配置文件会替代原来的主题配置文件生效，平常设置只要在这个新的配置中设置就可以了。</p></li></ol><ol start="2"><li><p>菜单栏这些跳转页面是需要创建页面才能生效的</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200709182615.png" alt="QQ截图20200628112427"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page 【tags或者categories或者link】</span><br></pre></td></tr></table></figure><p>该命令会在站点目录下source目录中生成一个对应tags或者categories文件夹，用于存放该页面的md文件</p><ul><li><p>Link页面：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page link</span><br></pre></td></tr></table></figure><p>该命令生成source \ link目录，内部包含link页面link.md，该文件内容头部type应该被修改为“link”，在source \ _data目录中创建link.yml，作为该页面内容的配置文件，该配置常见的写法如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">class_name:</span>   <span class="comment">#链接的类型</span></span><br><span class="line">  <span class="attr">class_desc:</span><span class="comment">#链接类型的描述  </span></span><br><span class="line">  <span class="attr">link_list:</span>    </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span><span class="comment">#链接的名称      </span></span><br><span class="line">    <span class="attr">link:</span><span class="comment">#具体链接地址      </span></span><br><span class="line">    <span class="attr">avatar:</span><span class="comment">#链接的头像该头像使用的地址应该为 \img\图片名称.xxx      </span></span><br><span class="line">    <span class="attr">descr:</span><span class="comment">#对该链接的描述</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">      <span class="string">.........</span><span class="comment">#该种链接可以不止一个</span></span><br></pre></td></tr></table></figure></li><li><p>Music页面：</p><p>首先为音乐页面生成页面md文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page music</span><br></pre></td></tr></table></figure><p>音乐界面播放插件使用的是aplayer，安装插件方式如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure><p>aplayer可以使用多种标签添加音乐，此处主要使用MetingJS，这个API内嵌在aplayer插件中了，Meting可以很容易的使用id引用网易云音乐等其他播放器的资源</p><p>在站点的_config.yml文件中添加使用aplayer的使用语句，注意，改动配置文件后需要通过<code>hexo clean</code>和<code>hexo g</code>重新生成</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aplayer:</span><br><span class="line">asset_inject: false#关闭asset表示不会为每个页面都插入aplayer头部信息，因为并不是每个页面都需要加入音乐</span><br><span class="line">meting: true</span><br></pre></td></tr></table></figure><p>在音乐页面的md文件中使用Meting标签插入音乐</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200709182545.png" alt="QQ截图20200630101945"></p><p>首先在音乐页面的md文件头部中加入aplayer:true，表示在该页面添加引用aplayer的插件的js信息</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% meting <span class="string">"id"</span> <span class="string">"server"</span> <span class="string">"type"</span> [可选参数]%&#125;</span><br><span class="line"><span class="comment">//id是音乐的id</span></span><br><span class="line"><span class="comment">//server是表示音乐为哪个平台的，可以是neteasetencentkugo xiami baidu</span></span><br><span class="line"><span class="comment">//type表示id属于什么类型，song、playlist、album、search、artist</span></span><br></pre></td></tr></table></figure></li><li><p>Movie页面：</p><p>这个页面可以放影评等等，可以通过豆瓣爬虫插件hexo-douban实现，该插件会自动爬取豆瓣的影评，同时生成相应页面，只要将该页面和主题配置文件中的引用地址关联起来，就可以设置movie显示的内容了</p></li></ul></li></ol><ol start="3"><li><p>404页面效果设置</p><p>在butterfly.yml主题配置中，设置error_404的配置项</p></li></ol><ol start="4"><li><p>导航菜单</p><p>在butterfly.yml配置文件中，menu项目下的内容代表了菜单栏的名称，各个页面存放的目录信息和图标名称，中间使用 || 号进行分割，图标使用的是Font Awesome。</p></li></ol><ol start="5"><li><p>代码显示的设置</p><ul><li><p>highlight_theme 设置代码显示样式</p></li><li><p>highlight_copy 设置是否有复制按钮</p></li><li><p>highlight_shrink 设置代码是否收缩</p></li><li><p>code_word_wrap 设置代码过长时是否换行</p></li></ul></li></ol><ol start="6"><li><p>设置社交图标</p><p>在butterfly.yml文件中，social项目可以配置显示什么社交信息，图标使用的是Font Awesome上的图标，可以在<a href="https://fontawesome.com/icons?d=gallery" target="_blank" rel="noopener">Font Awesome</a>网站上搜索使用的标签，|| 后放着的是说明该社交信息的描述</p></li></ol><ol start="7"><li><p>主页文章显示的一些文章的简要内容</p><p>通过设置butterfly.yml中的index_post_conten配置项，内容有三种形式，一种是显示文章头部的description，一种是随机选择内容显示，一种是两种结合，有description使用description，没有的话使用随机</p></li></ol><ol start="8"><li><p>页面头图的设置</p><p>在butterfly.yml文件中设置各个页面的头部图像，不过，首先使用的是这些页面的md文件中头部top_img的配置，如果该配置没有设置，才使用配置文件中的配置</p></li></ol><ol start="9"><li><p>文章的封面图片设置</p><p>在文章的头部中，设置cover：图片路径，用于设置文章的封面图片。butterfly.yml文件中也有cover项，该项用于设置文章封面图片的各种信息</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="attr">position:</span><span class="comment">#设置文章封面出现的位置left\right\both</span></span><br><span class="line">  <span class="attr">default_cover:</span> <span class="comment">#用于设置默认的文章封面</span></span><br></pre></td></tr></table></figure></li></ol><ol start="10"><li><p>文章的更新日期、创建日期、标签、类别的显示</p><p>在butterfly.yml文件中，设置post_meta项目，可以配置这些文章信息是不是显示在首页和文章内容中</p></li></ol><ol start="11"><li><p>设置文章下方的版权信息</p><p>在butterfly.yml文件中设置post_copyright项目，设置文章的版权信息，以及使用的licence</p></li></ol><ol start="12"><li><p>文章打赏设置</p><p>在butterfly.yml中，设置reward项目，用于设置收款码</p></li></ol><ol start="13"><li><p>设置显示文章的目录</p><p>在butterfly.yml文件中设置TOC栏目，用于是否显示文章的目录结构</p></li></ol><ol start="14"><li><p>显示相关文章的设置</p><p>在butterfly.yml配置中的related_post项目中设置是否启用相关设置</p></li></ol><ol start="15"><li><p>设置是否记录文章的浏览位置</p><p>在butterfly.yml文件中设置anchor可以控制记录文章的浏览位置，从而下次还原时可以知道文章浏览到哪里</p></li></ol><ol start="16"><li><p>设置头像</p><p>在butterfly.yml文件中设置avatar项目，用于设定头像的图片以及旋转效果</p></li></ol><ol start="17"><li><p>设置网站文字的繁简字体切换</p><p>在配置文件中设置translate项目，用于切换中文的繁简字体</p></li></ol><ol start="18"><li><p>设置侧边栏的效果</p><p>通过butterfly.yml文件中的aside项目可以设定侧边栏的显示内容和显示效果</p></li></ol><ol start="19"><li>本主题网站的访问统计是通过busuanzi进行统计的</li></ol><ol start="20"><li><p>添加评论</p><p>评论有很多可以使用的第三方插件，本站使用Gitalk添加评论，Gitalk的使用说明<a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md" target="_blank" rel="noopener">猛戳这里</a>，为部落格添加评论的过程如下</p><ul><li><p>Gitalk需要使用用户的GitHub个人信息作为区别评论人的标识，其遵循OAuth（开放授权协议），Github提供了申请OAuth应用的方法，需要申请如下</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200709175918.png" alt="QQ截图20200701174658"></p><p>申请后可以得到client_id等信息</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200709180251.png" alt></p></li><li><p>Gitalk还需要一个仓库用于存放评论信息，因此需要创建一个新的GitHub仓库，名称可以任意取</p></li><li><p>在butterfly.yml中需要对gitalk项目进行配置，其中之前得到的client_id和client_secret需要被填写在此处，而且存储仓库的名称也需要被填写在此处</p></li></ul></li></ol><ol start="21"><li><p>添加在线聊天功能</p><p>此处使用的是chatra提供的在线聊天功能，需要了解chatra请<a href="https://app.chatra.io/chat/xEhJm4wrdFbf4kKbE" target="_blank" rel="noopener">猛戳这里</a>，注册网站后需要得到API keys，同时在butterfly.yml中设定chatra项目，其中id选项表示API keys的值。chatra网站是需要付费使用的，只能试用10天。</p></li></ol><ol start="22"><li><p>文章下方的分享按钮</p><p>分享的实现是通过sharejs插件实现的，sharejs的详情<a href="https://github.com/overtrue/share.js/" target="_blank" rel="noopener">猛戳这里</a>，同时需要在butterfly中开启这个插件的使用。</p></li></ol><ol start="23"><li><p>开启站点的搜索功能</p><p>本文使用的是hexo-generator-search插件的搜索，该插件的使用需要进行安装和在站点配置文件_config.yml中设置启用该搜索插件，该插件的工作流程主要是为站点建立一个内容的索引文件，当搜索时就通过这个索引文件进行查找。该插件的详细信息可以<a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">猛戳这里</a>。</p><p>在_config.yml设置完后，还需要对butterfly.yml进行设置，其local_search项目需要进行配置</p></li></ol><ol start="24"><li><p>设置打字时出现的特效</p><p>在butterfly.yml中设置activate_power_mode，用于为打字时添加特效，比如抖动和颜色特效</p></li></ol><ol start="25"><li><p>设置背景的效果，比如彩带效果和鼠标可以汇点成网的效果</p><p>这些都是在butterfly.yml中的canvas项目中进行设置的，如canvas_ribbon、canvas_ribbon_piao、canvas_nest</p></li></ol><ol start="26"><li><p>美化页面</p><p>为文章的标题处添加额外的装饰，可以在butterfly.yml的beautify的项目中设定启用美化效果</p></li></ol><ol start="27"><li><p>网站的副标题</p><p>通过设置butterfly.yml文件中的subtitle可以设定网站的副标题的显示方式，包括显示的内容等等</p></li></ol><ol start="28"><li><p>网站字数统计</p><p>该字数统计使用的时wordcount插件，安装插件使用如下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>安装完成后需要在butterfly.yml文件的wordcount中启用字数统计插件</p></li></ol><ol start="29"><li><p>文章中的图片可以放大</p><p>butterfly.yml文件中，fancybox选项用于设定图片预览框，可以放大图片</p></li></ol><ol start="30"><li><p>使用snackbar设定更好看的弹窗</p><p>在butterfly.yml文件中可以设定snackbar弹窗的效果，其美化了传统的网页头部的弹窗，让其变得好看</p></li></ol><ol start="31"><li><p>为部落格添加一个看板娘</p><p>hexo有插件已经封装了看板娘，但是，原装的看板娘没有对话的特效，也没有侧边栏的一些功能，比如说换装、合影、游戏等等，为了添加一个更骚气的看板娘，这里使用了新的项目<a href="https://github.com/stevenjoezhang/live2d-widget" target="_blank" rel="noopener">猛戳这里</a>，在butterfly主题中，该项目的使用方式如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/stevenjoezhang/live2d-widget.git#将项目克隆到主题目录下的source文件夹中</span><br></pre></td></tr></table></figure><p>修改live2d-widget项目中的autoload.js文件，将第一行</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> live2d_path = <span class="string">"https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/"</span>;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> live2d_path = <span class="string">"/live2d-widget/"</span>;</span><br></pre></td></tr></table></figure><p>在butterflt / layout / includes / layout.pug文件中添加对于live2d的js引用，具体方法为在文件的head后添加</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link(rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;font-awesome&#x2F;css&#x2F;font-awesome.min.css&quot;)</span><br><span class="line">block scripts</span><br><span class="line">        script(src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js&quot;)</span><br><span class="line">        script(src&#x3D;&quot;&#x2F;live2d-widget&#x2F;autoload.js&quot;)</span><br></pre></td></tr></table></figure><p>在live2d_widget项目中waifu-tips.js、waifu-tips.json、waifu.css是用于设定看板娘的语言和鼠标事件对应的效果</p></li></ol><ol start="32"><li><p>为主题添加访问者地图统计</p><p>参考<a href="https://blog.csdn.net/cungudafa/article/details/105925710" target="_blank" rel="noopener">该博客</a>，实现</p><p>这里使用第三方clustrmaps提供的Web挂件（Web Widget），访问该网站请<a href="https://clustrmaps.com/" target="_blank" rel="noopener">猛戳这里</a>，这其实是一个查找地址的网站，它提供了一个网络挂件，可以可视化访问网站的位置，是通过记录访问ip的位置实现的。注册登录后，在页面下方找到如下图标。</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200709180359.png" alt="clustrmap"></p><p>输入想挂载这个挂件的网址，同时选择挂件是地图样式还是地球样式，这时会生成对应代码，只需要把该代码放在需要显示挂件的位置即可。</p><p>在本主题中，我打算把它放在侧边栏的倒数第二的位置，<strong>这里也是一个为侧边栏添加新的模块的通用方式</strong>：</p><ul><li><p>首先在butterfly.yml文件中aside项目下添加一个<code>card_visitor_map:true</code>用于控制是否开放该访客统计</p></li><li><p>butterfly / layout / includes / widget 目录中存放的是各种挂件的pug文件，在该目录下新建card_visitor_map.pug文件，名称同butterfly.yml中设定的，在index.pug中设定判断是否开放该功能的逻辑</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if theme.aside.card_visitor_map</span><br><span class="line">!&#x3D;partial(&#39;includes&#x2F;widget&#x2F;card_visitor_map&#39;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br></pre></td></tr></table></figure><p>当butterfly.yml文件中aside.card_visitor_map功能开放时，将应用card_visitor_map.pug文件中的代码</p></li><li><p>重新生成部落格项目后可以显示访客地图</p></li></ul></li></ol><ol start="33"><li><p>聊天式的关于页面</p><p>聊天式的关于页面使用的是一款JS自动聊天机器人Botui，该项目的使用可以<a href="https://docs.botui.org/install.html" target="_blank" rel="noopener">猛戳这里</a>，为部落格添加该机器人作为关于页面的步骤如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page "aboutme"#为关于页面生成对应的md文件</span><br></pre></td></tr></table></figure><p>在生成的aboutme.md文件中加入如下html代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>BotUI - Hello World<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/botui/build/botui.min.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/botui/build/botui-theme-default.css"</span> /&gt;</span></span><br><span class="line">    //此处为关键的两行引入botui相关样式</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"botui-app-container"</span> <span class="attr">id</span>=<span class="string">"hello-world"</span> <span class="attr">style</span>=<span class="string">"min-height:300px; padding:2px 6px 4px 6px; background-color: rgba(242, 242, 242,0.5); border-radius: 10px; 2px solid"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">h4</span>&gt;</span>与 YoYoghurt 对话中. . .<span class="tag">&lt;/<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bot-ui</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> " <span class="attr">background-image:</span> <span class="attr">url</span>(<span class="attr">https:</span>//<span class="attr">cdn.jsdelivr.net</span>/<span class="attr">gh</span>/<span class="attr">Fog-Forest</span>/<span class="attr">cdn</span>@<span class="attr">1.7</span>/<span class="attr">botui</span>/<span class="attr">loading.svg</span>); <span class="attr">background-repeat:</span> <span class="attr">no-repeat</span>;<span class="attr">background-size:</span> <span class="attr">10em</span>;<span class="attr">background-position:</span> <span class="attr">center</span>;<span class="attr">height:</span> <span class="attr">10em</span>;"&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bot-ui</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/vue/latest/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/botui/build/botui.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    //此处引入js文件，其使用了vue和botui两个js文件，都采用cdn加载安装方式</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> botui = <span class="keyword">new</span> BotUI(<span class="string">'hello-world'</span>);</span></span><br><span class="line">      botui.message.add(&#123;</span><br><span class="line">delay: 2000,</span><br><span class="line"><span class="actionscript">loading: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">        content: <span class="string">"Hi, 你好！"</span></span></span><br><span class="line"><span class="actionscript">      &#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; </span></span><br><span class="line">        botui.message.add(&#123;</span><br><span class="line">          delay: 2000,</span><br><span class="line"><span class="actionscript">  loading: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">          content: <span class="string">"这里是YoYoghurt，son of the summer，你的名字叫什么呢？"</span></span></span><br><span class="line"><span class="actionscript">        &#125;).then(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">  botui.action.text(&#123;</span><br><span class="line"><span class="actionscript">  action:&#123;placeholder: <span class="string">"告诉我你的名字吧！"</span>&#125;</span></span><br><span class="line"><span class="actionscript">  &#125;).then(<span class="function"><span class="keyword">function</span><span class="params">(res)</span></span>&#123;</span></span><br><span class="line">botui.message.add(&#123;</span><br><span class="line">delay: 2000,</span><br><span class="line"><span class="actionscript">loading: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">  content: <span class="string">"Oh，欢迎"</span>+res.value</span></span><br><span class="line"><span class="actionscript">&#125;).then(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">    botui.action.button(&#123;</span><br><span class="line">    delay:1600,</span><br><span class="line">    action: [&#123;</span><br><span class="line"><span class="actionscript">    text: <span class="string">"然后呢？"</span>,</span></span><br><span class="line"><span class="actionscript">    value: <span class="string">"sure"</span></span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line"><span class="actionscript">    text: <span class="string">"少废话！"</span>,</span></span><br><span class="line"><span class="actionscript">    value: <span class="string">"skip"</span></span></span><br><span class="line">    &#125;]</span><br><span class="line"><span class="actionscript">    &#125;).then(<span class="function"><span class="keyword">function</span><span class="params">(res)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span>(res.value == <span class="string">"sure"</span>)&#123;</span></span><br><span class="line">    sure();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span>(res.value == <span class="string">"skip"</span>)&#123;</span></span><br><span class="line">    skip();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> sure = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">      botui.message.add(&#123;</span><br><span class="line">      delay: 2000,</span><br><span class="line"><span class="actionscript">loading: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      content: <span class="string">"YoYoghurt是一个干啥啥不行，吃饭睡觉第一名的菜狗！！"</span></span></span><br><span class="line">      &#125;)</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> skip = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">       botui.message.add(&#123;</span><br><span class="line">       delay: 2000,</span><br><span class="line"><span class="actionscript">loading: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">       type: <span class="string">"html"</span>,</span></span><br><span class="line"><span class="handlebars"><span class="xml">       content: "说话好凶啊，<span class="tag">&lt;<span class="name">b</span>&gt;</span>哼！<span class="tag">&lt;/<span class="name">b</span>&gt;</span>不理你了，GUN. . ."</span></span></span><br><span class="line">       &#125;)</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>聊天的页面样式可以自定义，在botui官方教程中有详细说明。</p></li></ol><ol start="34"><li><p>为部落格绑定域名</p><p>通常部落格采用默认地址<a href="http://username.github.io进行访问，如果想要使用更加炫酷的域名访问博客就需要将gitpage和购买的域名进行绑定。" target="_blank" rel="noopener">http://username.github.io进行访问，如果想要使用更加炫酷的域名访问博客就需要将gitpage和购买的域名进行绑定。</a></p><p>首先，再阿里云上购买域名，购买域名时需要实现实名制认证，认证通过一般十几分钟，还需要进行邮箱验证，才可以购买，购买域名后进入域名控制台，如下</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200709180534.png" alt="域名"></p><p>点击解析域名</p><p><img src= "https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200705173220.gif" data-src="https://cdn.jsdelivr.net/gh/Mr-Yellow/ImgHosting/Blog-Pic20200709180632.png" alt="域名2"></p><p>解析域名时通过添加记录增加解析的目的地，要增加两条解析记录，这很关键，其中一个记录时@一个时www记录，类型一个时CNAME，一个时A类型，记录值都是gitpage的ip。gitpage的ip可以通过</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping username.github.io</span><br></pre></td></tr></table></figure><p>获得gitpage的ip地址。在GitHub存储部落格的仓库中，需要增加一个标记新域名的CNAME文件，但是这个文件需要放在source目录下，经过<code>hexo g</code>生成后放在public目录下，经过<code>hexo deploy</code>部署后被上传到仓库中。</p><p>CNAME文件没有后缀名，文件名直接是CNAME，内容是要绑定的域名，<strong>注意</strong>是域名，不要包含主机号。</p></li></ol><ol start="35"><li><p>为部落格添加豆瓣个人信息</p><p>如果想要在主页上显示在豆瓣上发表的影评、书评之类的，需要使用hexo-douban这个插件，该插件详细的使用说明<a href="https://github.com/mythsman/hexo-douban" target="_blank" rel="noopener">猛戳这里</a>，这个插件实际上是一个爬虫，它会爬取我在豆瓣上发表的影评和书评信息，并且生成一个网页文件，同时放到public目录下的movies和books文件夹中，在部落格上只要引用改文件夹的位置，就可以显示相应的页面</p><p>安装命令为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-douban --save</span><br></pre></td></tr></table></figure><p>在站点的配置文件中写入以下信息：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">douban:</span></span><br><span class="line">  <span class="comment">#user是个人的编号，可以从豆瓣个人中心的url中获得</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">mythsman</span></span><br><span class="line">  <span class="comment">#此处需要为true，这样可以在hexo g生成页面的时候一块生成爬取的页面，否则需要手动生成爬取的页面hexo douban</span></span><br><span class="line">  <span class="attr">builtin:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">book:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">'This is my book title'</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">'This is my book quote'</span></span><br><span class="line">  <span class="attr">movie:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">'This is my movie title'</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">'This is my movie quote'</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/06/24/hello-world/"/>
      <url>/2020/06/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
